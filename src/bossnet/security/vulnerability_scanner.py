"""
Comprehensive Vulnerability Scanner for Bangladesh Education Data Warehouse
Scans dependencies, code, containers, and web application for security vulnerabilities
"""

import asyncio
import json
import os
import re
import subprocess
import tempfile
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import aiofiles
import aiohttp
from pydantic import BaseModel, Field
from sqlalchemy import JSON, Boolean, Column, DateTime, Integer, String, Text
from sqlalchemy.orm import Session

from audit.audit_service import AuditService
from config.settings import settings
from database.base import Base


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels"""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ScanType(str, Enum):
    """Types of security scans"""

    DEPENDENCY = "dependency"
    CODE = "code"
    CONTAINER = "container"
    WEB = "web"
    INFRASTRUCTURE = "infrastructure"


class VulnerabilityStatus(str, Enum):
    """Vulnerability status"""

    OPEN = "open"
    ACKNOWLEDGED = "acknowledged"
    FIXED = "fixed"
    FALSE_POSITIVE = "false_positive"


class VulnerabilityScanModel(Base):
    """Vulnerability scan results model"""

    __tablename__ = "vulnerability_scans"

    id = Column(Integer, primary_key=True, index=True)
    scan_id = Column(String(64), unique=True, nullable=False, index=True)
    scan_type = Column(String(20), nullable=False, index=True)
    target = Column(String(255), nullable=False)  # File, URL, container, etc.

    # Scan metadata
    started_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime, nullable=True)
    duration_seconds = Column(Integer, nullable=True)

    # Results
    total_vulnerabilities = Column(Integer, default=0, nullable=False)
    critical_count = Column(Integer, default=0, nullable=False)
    high_count = Column(Integer, default=0, nullable=False)
    medium_count = Column(Integer, default=0, nullable=False)
    low_count = Column(Integer, default=0, nullable=False)

    # Status
    status = Column(String(20), default="running", nullable=False)  # running, completed, failed
    error_message = Column(Text, nullable=True)

    # Raw results
    raw_results = Column(JSON, nullable=True)

    def is_completed(self) -> bool:
        return self.status == "completed"

    def get_risk_score(self) -> int:
        """Calculate risk score based on vulnerabilities"""
        return self.critical_count * 10 + self.high_count * 7 + self.medium_count * 4 + self.low_count * 1


class VulnerabilityModel(Base):
    """Individual vulnerability model"""

    __tablename__ = "vulnerabilities"

    id = Column(Integer, primary_key=True, index=True)
    scan_id = Column(String(64), nullable=False, index=True)

    # Vulnerability details
    vulnerability_id = Column(String(100), nullable=False, index=True)  # CVE, CWE, etc.
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    severity = Column(String(20), nullable=False, index=True)

    # Location
    file_path = Column(String(500), nullable=True)
    line_number = Column(Integer, nullable=True)
    function_name = Column(String(255), nullable=True)

    # Package/dependency info
    package_name = Column(String(255), nullable=True, index=True)
    package_version = Column(String(100), nullable=True)
    fixed_version = Column(String(100), nullable=True)

    # Status and remediation
    status = Column(String(20), default=VulnerabilityStatus.OPEN.value, nullable=False)
    remediation = Column(Text, nullable=True)
    references = Column(JSON, nullable=True)  # URLs, CVE links, etc.

    # Metadata
    first_detected = Column(DateTime, default=datetime.utcnow, nullable=False)
    last_seen = Column(DateTime, default=datetime.utcnow, nullable=False)
    false_positive = Column(Boolean, default=False, nullable=False)

    def get_cvss_score(self) -> Optional[float]:
        """Extract CVSS score from references if available"""
        if not self.references:
            return None

        for ref in self.references:
            if isinstance(ref, dict) and "cvss_score" in ref:
                return float(ref["cvss_score"])

        return None


class ScanResult(BaseModel):
    """Scan result response"""

    scan_id: str
    scan_type: str
    target: str
    status: str
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    risk_score: int
    started_at: datetime
    completed_at: Optional[datetime] = None
    duration_seconds: Optional[int] = None


class VulnerabilityDetail(BaseModel):
    """Vulnerability detail response"""

    vulnerability_id: str
    title: str
    description: Optional[str] = None
    severity: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    package_name: Optional[str] = None
    package_version: Optional[str] = None
    fixed_version: Optional[str] = None
    status: str
    remediation: Optional[str] = None
    references: Optional[List[Dict[str, Any]]] = None
    cvss_score: Optional[float] = None


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner"""

    def __init__(self):
        self.audit_service = AuditService()
        self.project_root = Path.cwd()

        # Tool configurations
        self.tools = {
            "safety": self._check_safety_installed(),
            "bandit": self._check_bandit_installed(),
            "trivy": self._check_trivy_installed(),
            "semgrep": self._check_semgrep_installed(),
        }

    def _check_safety_installed(self) -> bool:
        """Check if Safety is installed"""
        try:
            subprocess.run(["safety", "--version"], capture_output=True, check=True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _check_bandit_installed(self) -> bool:
        """Check if Bandit is installed"""
        try:
            subprocess.run(["bandit", "--version"], capture_output=True, check=True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _check_trivy_installed(self) -> bool:
        """Check if Trivy is installed"""
        try:
            subprocess.run(["trivy", "--version"], capture_output=True, check=True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _check_semgrep_installed(self) -> bool:
        """Check if Semgrep is installed"""
        try:
            subprocess.run(["semgrep", "--version"], capture_output=True, check=True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    async def start_scan(self, scan_type: ScanType, target: str, db: Session, options: Optional[Dict[str, Any]] = None) -> str:
        """Start a vulnerability scan"""
        scan_id = f"scan_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{scan_type.value}"

        # Create scan record
        scan_record = VulnerabilityScanModel(scan_id=scan_id, scan_type=scan_type.value, target=target, status="running")

        db.add(scan_record)
        db.commit()

        # Log scan start
        await self.audit_service.log_event(
            event_type="security",
            action="vulnerability_scan_started",
            details={"scan_id": scan_id, "scan_type": scan_type.value, "target": target},
            severity="medium",
            db=db,
        )

        # Start scan in background
        asyncio.create_task(self._execute_scan(scan_id, scan_type, target, options or {}, db))

        return scan_id

    async def _execute_scan(self, scan_id: str, scan_type: ScanType, target: str, options: Dict[str, Any], db: Session):
        """Execute the actual scan"""
        start_time = datetime.utcnow()

        try:
            if scan_type == ScanType.DEPENDENCY:
                results = await self._scan_dependencies(target, options)
            elif scan_type == ScanType.CODE:
                results = await self._scan_code(target, options)
            elif scan_type == ScanType.CONTAINER:
                results = await self._scan_container(target, options)
            elif scan_type == ScanType.WEB:
                results = await self._scan_web_application(target, options)
            else:
                raise ValueError(f"Unsupported scan type: {scan_type}")

            # Process and store results
            await self._process_scan_results(scan_id, results, db)

            # Update scan record
            scan_record = db.query(VulnerabilityScanModel).filter(VulnerabilityScanModel.scan_id == scan_id).first()

            if scan_record:
                scan_record.completed_at = datetime.utcnow()
                scan_record.duration_seconds = int((scan_record.completed_at - start_time).total_seconds())
                scan_record.status = "completed"
                scan_record.raw_results = results
                db.commit()

            # Log scan completion
            await self.audit_service.log_event(
                event_type="security",
                action="vulnerability_scan_completed",
                details={
                    "scan_id": scan_id,
                    "scan_type": scan_type.value,
                    "duration_seconds": scan_record.duration_seconds,
                    "total_vulnerabilities": scan_record.total_vulnerabilities,
                },
                severity="low",
                db=db,
            )

        except Exception as e:
            # Update scan record with error
            scan_record = db.query(VulnerabilityScanModel).filter(VulnerabilityScanModel.scan_id == scan_id).first()

            if scan_record:
                scan_record.completed_at = datetime.utcnow()
                scan_record.duration_seconds = int((scan_record.completed_at - start_time).total_seconds())
                scan_record.status = "failed"
                scan_record.error_message = str(e)
                db.commit()

            # Log scan failure
            await self.audit_service.log_event(
                event_type="security",
                action="vulnerability_scan_failed",
                details={"scan_id": scan_id, "scan_type": scan_type.value, "error": str(e)},
                severity="high",
                db=db,
            )

    async def _scan_dependencies(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Scan dependencies for known vulnerabilities using Safety"""
        if not self.tools["safety"]:
            raise RuntimeError("Safety tool not installed")

        results = {"tool": "safety", "vulnerabilities": [], "summary": {"total": 0, "by_severity": {}}}

        try:
            # Run Safety check
            cmd = ["safety", "check", "--json"]
            if target and target != ".":
                cmd.extend(["--file", target])

            process = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=self.project_root
            )

            stdout, stderr = await process.communicate()

            if process.returncode == 0:
                # No vulnerabilities found
                return results

            # Parse Safety JSON output
            try:
                safety_results = json.loads(stdout.decode())

                for vuln in safety_results:
                    vulnerability = {
                        "id": vuln.get("id", ""),
                        "title": f"Vulnerable dependency: {vuln.get('package_name', 'Unknown')}",
                        "description": vuln.get("advisory", ""),
                        "severity": self._map_safety_severity(vuln.get("id", "")),
                        "package_name": vuln.get("package_name", ""),
                        "package_version": vuln.get("installed_version", ""),
                        "fixed_version": ", ".join(vuln.get("safe_versions", [])),
                        "references": [{"url": f"https://pyup.io/vulnerabilities/{vuln.get('id', '')}/"}],
                    }

                    results["vulnerabilities"].append(vulnerability)

                # Update summary
                results["summary"]["total"] = len(results["vulnerabilities"])
                for vuln in results["vulnerabilities"]:
                    severity = vuln["severity"]
                    results["summary"]["by_severity"][severity] = results["summary"]["by_severity"].get(severity, 0) + 1

            except json.JSONDecodeError:
                # Fallback to text parsing
                output_text = stdout.decode()
                results["raw_output"] = output_text

        except Exception as e:
            results["error"] = str(e)

        return results

    def _map_safety_severity(self, vuln_id: str) -> str:
        """Map Safety vulnerability ID to severity level"""
        # This is a simplified mapping - in practice, you'd use CVE databases
        # or Safety's own severity ratings
        if vuln_id.startswith("CVE-"):
            return VulnerabilitySeverity.HIGH.value
        return VulnerabilitySeverity.MEDIUM.value

    async def _scan_code(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Scan code for security issues using Bandit"""
        if not self.tools["bandit"]:
            raise RuntimeError("Bandit tool not installed")

        results = {"tool": "bandit", "vulnerabilities": [], "summary": {"total": 0, "by_severity": {}}}

        try:
            # Run Bandit scan
            cmd = ["bandit", "-r", target or ".", "-f", "json"]

            process = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, cwd=self.project_root
            )

            stdout, stderr = await process.communicate()

            # Parse Bandit JSON output
            try:
                bandit_results = json.loads(stdout.decode())

                for result in bandit_results.get("results", []):
                    vulnerability = {
                        "id": result.get("test_id", ""),
                        "title": result.get("test_name", ""),
                        "description": result.get("issue_text", ""),
                        "severity": result.get("issue_severity", "").lower(),
                        "confidence": result.get("issue_confidence", ""),
                        "file_path": result.get("filename", ""),
                        "line_number": result.get("line_number", 0),
                        "code": result.get("code", ""),
                        "references": [
                            {
                                "url": f"https://bandit.readthedocs.io/en/latest/plugins/{result.get('test_id', '').lower()}.html"
                            }
                        ],
                    }

                    results["vulnerabilities"].append(vulnerability)

                # Update summary
                results["summary"]["total"] = len(results["vulnerabilities"])
                for vuln in results["vulnerabilities"]:
                    severity = vuln["severity"]
                    results["summary"]["by_severity"][severity] = results["summary"]["by_severity"].get(severity, 0) + 1

            except json.JSONDecodeError:
                results["raw_output"] = stdout.decode()

        except Exception as e:
            results["error"] = str(e)

        return results

    async def _scan_container(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Scan container image for vulnerabilities using Trivy"""
        if not self.tools["trivy"]:
            raise RuntimeError("Trivy tool not installed")

        results = {"tool": "trivy", "vulnerabilities": [], "summary": {"total": 0, "by_severity": {}}}

        try:
            # Run Trivy scan
            cmd = ["trivy", "image", "--format", "json", target]

            process = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                results["error"] = stderr.decode()
                return results

            # Parse Trivy JSON output
            try:
                trivy_results = json.loads(stdout.decode())

                for result in trivy_results.get("Results", []):
                    for vuln in result.get("Vulnerabilities", []):
                        vulnerability = {
                            "id": vuln.get("VulnerabilityID", ""),
                            "title": vuln.get("Title", ""),
                            "description": vuln.get("Description", ""),
                            "severity": vuln.get("Severity", "").lower(),
                            "package_name": vuln.get("PkgName", ""),
                            "package_version": vuln.get("InstalledVersion", ""),
                            "fixed_version": vuln.get("FixedVersion", ""),
                            "references": [{"url": url} for url in vuln.get("References", [])],
                        }

                        results["vulnerabilities"].append(vulnerability)

                # Update summary
                results["summary"]["total"] = len(results["vulnerabilities"])
                for vuln in results["vulnerabilities"]:
                    severity = vuln["severity"]
                    results["summary"]["by_severity"][severity] = results["summary"]["by_severity"].get(severity, 0) + 1

            except json.JSONDecodeError:
                results["raw_output"] = stdout.decode()

        except Exception as e:
            results["error"] = str(e)

        return results

    async def _scan_web_application(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Scan web application for common vulnerabilities"""
        results = {"tool": "custom_web_scanner", "vulnerabilities": [], "summary": {"total": 0, "by_severity": {}}}

        try:
            # Basic web application security checks
            vulnerabilities = []

            # Check for common security headers
            async with aiohttp.ClientSession() as session:
                try:
                    async with session.get(target, timeout=10) as response:
                        headers = response.headers

                        # Check for missing security headers
                        security_headers = {
                            "X-Content-Type-Options": "nosniff",
                            "X-Frame-Options": ["DENY", "SAMEORIGIN"],
                            "X-XSS-Protection": "1; mode=block",
                            "Strict-Transport-Security": None,
                            "Content-Security-Policy": None,
                        }

                        for header, expected in security_headers.items():
                            if header not in headers:
                                vulnerabilities.append(
                                    {
                                        "id": f"missing_{header.lower().replace('-', '_')}",
                                        "title": f"Missing {header} header",
                                        "description": f"The {header} security header is not set",
                                        "severity": VulnerabilitySeverity.MEDIUM.value,
                                        "remediation": f"Add {header} header to HTTP responses",
                                    }
                                )

                        # Check for insecure cookies
                        for cookie in response.cookies:
                            if not cookie.get("secure"):
                                vulnerabilities.append(
                                    {
                                        "id": "insecure_cookie",
                                        "title": "Insecure cookie",
                                        "description": f"Cookie '{cookie.key}' is not marked as secure",
                                        "severity": VulnerabilitySeverity.MEDIUM.value,
                                        "remediation": "Set Secure flag on cookies",
                                    }
                                )

                            if not cookie.get("httponly"):
                                vulnerabilities.append(
                                    {
                                        "id": "httponly_cookie",
                                        "title": "Cookie accessible via JavaScript",
                                        "description": f"Cookie '{cookie.key}' is not marked as HttpOnly",
                                        "severity": VulnerabilitySeverity.LOW.value,
                                        "remediation": "Set HttpOnly flag on cookies",
                                    }
                                )

                        # Check for server information disclosure
                        server_header = headers.get("Server", "")
                        if server_header and any(tech in server_header.lower() for tech in ["apache", "nginx", "iis"]):
                            vulnerabilities.append(
                                {
                                    "id": "server_disclosure",
                                    "title": "Server information disclosure",
                                    "description": f"Server header reveals: {server_header}",
                                    "severity": VulnerabilitySeverity.LOW.value,
                                    "remediation": "Remove or obfuscate Server header",
                                }
                            )

                except aiohttp.ClientError as e:
                    results["error"] = f"Failed to connect to {target}: {str(e)}"
                    return results

            results["vulnerabilities"] = vulnerabilities
            results["summary"]["total"] = len(vulnerabilities)

            for vuln in vulnerabilities:
                severity = vuln["severity"]
                results["summary"]["by_severity"][severity] = results["summary"]["by_severity"].get(severity, 0) + 1

        except Exception as e:
            results["error"] = str(e)

        return results

    async def _process_scan_results(self, scan_id: str, results: Dict[str, Any], db: Session):
        """Process and store scan results"""
        vulnerabilities = results.get("vulnerabilities", [])

        # Count vulnerabilities by severity
        severity_counts = {
            VulnerabilitySeverity.CRITICAL.value: 0,
            VulnerabilitySeverity.HIGH.value: 0,
            VulnerabilitySeverity.MEDIUM.value: 0,
            VulnerabilitySeverity.LOW.value: 0,
        }

        # Store individual vulnerabilities
        for vuln_data in vulnerabilities:
            severity = vuln_data.get("severity", VulnerabilitySeverity.LOW.value)
            severity_counts[severity] += 1

            vulnerability = VulnerabilityModel(
                scan_id=scan_id,
                vulnerability_id=vuln_data.get("id", ""),
                title=vuln_data.get("title", ""),
                description=vuln_data.get("description", ""),
                severity=severity,
                file_path=vuln_data.get("file_path"),
                line_number=vuln_data.get("line_number"),
                function_name=vuln_data.get("function_name"),
                package_name=vuln_data.get("package_name"),
                package_version=vuln_data.get("package_version"),
                fixed_version=vuln_data.get("fixed_version"),
                remediation=vuln_data.get("remediation"),
                references=vuln_data.get("references", []),
            )

            db.add(vulnerability)

        # Update scan record with counts
        scan_record = db.query(VulnerabilityScanModel).filter(VulnerabilityScanModel.scan_id == scan_id).first()

        if scan_record:
            scan_record.total_vulnerabilities = len(vulnerabilities)
            scan_record.critical_count = severity_counts[VulnerabilitySeverity.CRITICAL.value]
            scan_record.high_count = severity_counts[VulnerabilitySeverity.HIGH.value]
            scan_record.medium_count = severity_counts[VulnerabilitySeverity.MEDIUM.value]
            scan_record.low_count = severity_counts[VulnerabilitySeverity.LOW.value]

        db.commit()

    def get_scan_results(self, scan_id: str, db: Session) -> Optional[ScanResult]:
        """Get scan results"""
        scan_record = db.query(VulnerabilityScanModel).filter(VulnerabilityScanModel.scan_id == scan_id).first()

        if not scan_record:
            return None

        return ScanResult(
            scan_id=scan_record.scan_id,
            scan_type=scan_record.scan_type,
            target=scan_record.target,
            status=scan_record.status,
            total_vulnerabilities=scan_record.total_vulnerabilities,
            critical_count=scan_record.critical_count,
            high_count=scan_record.high_count,
            medium_count=scan_record.medium_count,
            low_count=scan_record.low_count,
            risk_score=scan_record.get_risk_score(),
            started_at=scan_record.started_at,
            completed_at=scan_record.completed_at,
            duration_seconds=scan_record.duration_seconds,
        )

    def get_vulnerabilities(self, scan_id: str, db: Session) -> List[VulnerabilityDetail]:
        """Get detailed vulnerabilities for a scan"""
        vulnerabilities = db.query(VulnerabilityModel).filter(VulnerabilityModel.scan_id == scan_id).all()

        return [
            VulnerabilityDetail(
                vulnerability_id=vuln.vulnerability_id,
                title=vuln.title,
                description=vuln.description,
                severity=vuln.severity,
                file_path=vuln.file_path,
                line_number=vuln.line_number,
                package_name=vuln.package_name,
                package_version=vuln.package_version,
                fixed_version=vuln.fixed_version,
                status=vuln.status,
                remediation=vuln.remediation,
                references=vuln.references,
                cvss_score=vuln.get_cvss_score(),
            )
            for vuln in vulnerabilities
        ]

    def get_scan_history(self, limit: int = 50, db: Session = None) -> List[ScanResult]:
        """Get scan history"""
        scans = db.query(VulnerabilityScanModel).order_by(VulnerabilityScanModel.started_at.desc()).limit(limit).all()

        return [
            ScanResult(
                scan_id=scan.scan_id,
                scan_type=scan.scan_type,
                target=scan.target,
                status=scan.status,
                total_vulnerabilities=scan.total_vulnerabilities,
                critical_count=scan.critical_count,
                high_count=scan.high_count,
                medium_count=scan.medium_count,
                low_count=scan.low_count,
                risk_score=scan.get_risk_score(),
                started_at=scan.started_at,
                completed_at=scan.completed_at,
                duration_seconds=scan.duration_seconds,
            )
            for scan in scans
        ]

    def get_vulnerability_statistics(self, db: Session) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        total_scans = db.query(VulnerabilityScanModel).count()
        completed_scans = db.query(VulnerabilityScanModel).filter(VulnerabilityScanModel.status == "completed").count()

        total_vulnerabilities = db.query(VulnerabilityModel).count()
        open_vulnerabilities = (
            db.query(VulnerabilityModel).filter(VulnerabilityModel.status == VulnerabilityStatus.OPEN.value).count()
        )

        # Vulnerabilities by severity
        severity_stats = {}
        for severity in VulnerabilitySeverity:
            count = (
                db.query(VulnerabilityModel)
                .filter(
                    VulnerabilityModel.severity == severity.value, VulnerabilityModel.status == VulnerabilityStatus.OPEN.value
                )
                .count()
            )
            severity_stats[severity.value] = count

        # Recent scan activity
        recent_scans = (
            db.query(VulnerabilityScanModel)
            .filter(VulnerabilityScanModel.started_at >= datetime.utcnow() - timedelta(days=7))
            .count()
        )

        return {
            "total_scans": total_scans,
            "completed_scans": completed_scans,
            "total_vulnerabilities": total_vulnerabilities,
            "open_vulnerabilities": open_vulnerabilities,
            "vulnerabilities_by_severity": severity_stats,
            "recent_scans": recent_scans,
        }

    async def schedule_automated_scans(self, db: Session):
        """Schedule automated vulnerability scans"""
        # This would integrate with a task scheduler like Celery
        # to run scans on a regular schedule

        scan_schedule = [
            {"type": ScanType.DEPENDENCY, "target": "requirements.txt", "frequency": "daily"},
            {"type": ScanType.CODE, "target": "src/", "frequency": "weekly"},
            {"type": ScanType.WEB, "target": f"http://localhost:{settings.PORT}", "frequency": "weekly"},
        ]

        # Implementation would create scheduled tasks
        pass
